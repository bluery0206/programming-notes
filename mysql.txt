



-- KEYWORDS WITH *KEYWORD* ARE OPTIONAL

-- SELECT
	SELECT *DISTINCT* (columnNames) *alias
	FROM tableName
	*WHERE condition*
	*GROUP BY colName*
	*ORDER_BY DESC|ASC*
	*LIMIT intValue *OFFSET intValue**

-- INSERT
	INSERT INTO tableName *(columnNames)*
	VALUES (val1, valN, ...)
	WHERE condition

-- UPDATE
	UPDATE tableName
	SET colName1 = val1, colNameN = valN

-- DELETE
	DELETE FROM table_name WHERE condition;



-- WHERE
	-- Acts like a filter
	SELECT * FROM users
	WHERE 
		columnName = value
		columnName LIKE %_value_%
		columnName IS *NOT* NULL
		columnName IN (val1, valN, ... | subquery)
		columnName *NOT* BETWEEN val1 AND val2 

-- DISTINCT
	-- Returns rows with unique values
	SELECT DISTINCT username FROM users;

-- COLUMNS
	-- Columns that are going to be returned

	-- * - All columns 
	-- colName - One specific column 
	-- (colName1, colNameN, ...) - Multi-columns

	DESCRIBE table_name
	SHOW COLUMNS FROM table_name;

-- ALIAS
	-- Another name
	TableName AS aliasName
	TableName AS "alias name"
	TableName aliasName
	TableName "alias name"

-- LIKE 
	'a%'	start with "a"
	'%a'	end with "a"
	'%or%'	have "or" in any position
	'_r%'	have "r" in the second position
	'a_%'	start with "a" and are at least 2 characters in length
	'a__%'	start with "a" and are at least 3 characters in length
	'a%o'	start with "a" and ends with "o"

-- METHODS
	-- MIN(columnName) -> Returns the row with the smallest value of the specified row 
	-- MAX(columnName) -> Returns the row with the highest value of the specified row 
	-- COUNT(columnName) -> Returns how many rows are there
	-- AVG(columnName) -> Returns average of the numeric column
	-- SUM(columnName) -> Returns the total sum of the numeric column
	-- CONCAT(colName1, ", " , colNameN) -> Concatenates all the args 
	-- SELECT name, IFNULL(nickname, 'No nickname') FROM users; -- Returns "no nickname" if nickname is null
	-- SELECT COALESCE(nickname, username, 'Anonymous') AS display_name FROM users; -- if idx0 is null, return idx1 and if idx1 is null then return idx2

-- JOINS
	SELECT tab_a.order_id, tab_b.customer_name, tab_a.order_date
	FROM tab_a <JOIN_TYPE> JOIN tab_b ON tab_a.customer_id = tab_b.customer_id;

	-- JOIN_TYPE:
		INNER JOIN: Returns row with data in both tables
		LEFT JOIN: Returns * col from left, and * from right and leaves empty rows in right empty
		RIGHT JOIN: Returns the same as the LEFT but flipped
		CROSS JOIN: Returns all records from both tables

-- UNION
	-- Must have same cols in SELECT and only returns unique rows

	-- Example:
		SELECT name, email FROM students
		UNION
		SELECT name, email FROM teachers;

	-- UNION ALL > Allow returning all including with duplicates

-- HAVING
	-- HAVING exists because WHERE cant be used after GROUP BY 
	SELECT column_name(s)
	FROM table_name
	WHERE condition
	GROUP BY column_name(s)
	HAVING condition
	ORDER BY column_name(s);

-- EXISTS
	-- Checking if a row exists then return the selected column

	SELECT name
	FROM stores
	WHERE EXISTS (
		SELECT name 
		FROM items 
		WHERE 
			items.id = stores.id 
			AND 
			price items.price < 20
	);

	-- CHECK IF SOMETHING EXISTS
		SELECT EXISTS (
	    	SELECT 1 
	    	FROM users 
	    	WHERE email = 'test@example.com'
		);

-- ANY and ALL
	-- works with numerical valued columns and date

	-- ANY
		-- “Get all products whose price is greater than any of the prices from budget category”
		-- "ANY returns TRUE if at least one value from the subquery meets the condition."

		SELECT * FROM products
		WHERE price > ANY (
		    SELECT price FROM products WHERE category = 'budget'
		);

	ALL 
		-- “Get the MAX(score) from the column, EXCEPT mine, then check if mine is higher.”
		-- "ALL returns TRUE only if the condition is true for all values in the subquery."

		SELECT name FROM students
		WHERE score > ANY (
		  SELECT score FROM students WHERE section = 'B'
		);

-- DATABASE
	CREATE DATABASE databasename;
	DROP DATABASE databasename;
	SHOW TABLES
	SHOW DATABASES

-- TABLE
	CREATE TABLE Persons (
	    -- PRIMARY KEY
	    id INT AUTO_INCREMENT PRIMARY KEY,

	    -- BASIC STRING
	    first_name VARCHAR(50) NOT NULL,

	    -- UNIQUE CONSTRAINT ON MULTIPLE COLUMNS
	    address VARCHAR(255),
	    city VARCHAR(100),
	    CONSTRAINT unique_full_address UNIQUE (address, city),

	    -- DATE & TIME
	    birth_date DATE,
	    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
	    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

	    -- BOOLEAN & ENUM
	    is_active BOOLEAN DEFAULT TRUE,
	    gender ENUM('male', 'female', 'other') NOT NULL,

	    -- NUMERIC
	    age INT CHECK (age >= 0 AND age <= 120),
	    height DECIMAL(5,2), -- ex: 170.25 cm
    	CHECK (age>=18)

    	-- (assuming there's a Countries table)
	    -- FOREIGN KEY 
	    country_id INT,
	    CONSTRAINT fk_country FOREIGN KEY (country_id) REFERENCES Countries(country_id)

	    -- INDEXING
	    INDEX idx_city (city),
	    INDEX idx_name (last_name, first_name)
	);

	DROP TABLE table_name; // Deletes the table

	TRUNCATE TABLE table_name; // Deletes the rows 

	RENAME TABLE old_name TO new_name

	ALTER TABLE Customers
	    ADD PRIMARY KEY (ID);

		ADD email varchar(20)
		MODIFY COLUMN email text(255)
		DROP COLUMN email
		
		ADD UNIQUE col_name
		DROP UNIQUE col_name

		ADD CONSTRAINT allowed_age CHECK (age >= 18);
		DROP CHECK allowed_age;
		
		ADD CONSTRAINT unique_person UNIQUE (id,last_name)
		DROP CONSTRAINT unique_person


		???? DROP INDEX UC_Person
	    ???? ADD CONSTRAINT PK_Person PRIMARY KEY (ID,LastName)
		???? DROP FOREIGN KEY FK_PersonOrder;


-- DATE TYPES
	DATE - format YYYY-MM-DD
	DATETIME - format: YYYY-MM-DD HH:MI:SS
	TIMESTAMP - format: YYYY-MM-DD HH:MI:SS
	YEAR - format YYYY or YY


-- VIEW 
	-- A named query ready to be called

	CREATE VIEW active_students AS
	SELECT id, name, section
	FROM students
	WHERE is_active = 1;

	-- Example:
		SELECT * FROM active_students;

	CREATE OR REPLACE VIEW view_name AS
	SELECT col1, col2
	FROM table_name
	WHERE condition;

	DROP VIEW view_name;
	DROP VIEW IF EXISTS view_name;



-- EXTRAS
	-- SELECTING TWO TABLES (NOT PREFERABLE UNLESS FETCHING)
		SELECT t1.col_name, t2.col_name
		FROM t1. t2
		WHERE t1.col_name = value AND t2.col_name = value

		-- USING ALIAS
			SELECT t1.col_name, t2.col_name
			FROM TableOne as t1, TableTwo as t2
			WHERE t1.col_name = value AND t2.col_name = value


INDEX
	-- PROS: 
	-- 		Makes search fast as fuck

	-- CONS:
	-- 		Slows down INSERTs, UPDATEs, DELETEs due to index updates

	-- USAGE:
	-- 		- Make sure no duplicates are allowed in the col
	-- 		used for search
	-- 		- Dont index columns that change/updates a lot
	-- 		- Dont use for columns with bool values
	-- 		- Just do regular SELECT query. 

	-- AUTO-INDEXED columns
	-- 		- PRIMARY KEYS
	-- 		- FOREIGN KEYS

	CREATE TABLE users (id, username, email, password);

	-- If always search by email
	CREATE INDEX idx_email ON users(email);

	-- If you always search by combo, e.g., WHERE first_name = ? AND last_name = ?
	-- only works if you search for:
	-- 		`WHERE x = val`, 
	-- 		`x = val AND y = val`, 
	-- 	but NOT:
	-- 		`y = val`
	CREATE INDEX idx_fullname ON users(first_name, last_name);

	-- CHECK INDEXES
	SHOW INDEXES FROM users;

	-- DROP INDEXES
	DROP INDEX idx_email ON users;


-- CASE
	SELECT name,
		CASE 
			WHEN score >= 90 THEN 'A'
			WHEN score >= 80 THEN 'B'
			ELSE 'C'
		END AS grade
	FROM students;


-- TRANSACTION
	START TRANSACTION;

	INSERT INTO orders (...) VALUES (...);
	SAVEPOINT before_discount;

	UPDATE orders SET total = total * 0.8 WHERE user_id = 3;

	-- Uh-oh something went sus
	ROLLBACK TO SAVEPOINT before_discount;

	COMMIT;

	-- METHODS
		-- ROLLBACK (no savepoint)	Undo everything in the transaction
		-- SET autocommit = 0;	Prevents auto-committing queries
